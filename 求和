求和
https://vijos.org/p/1976
-----------------------------------------------------------------------------------------------------------------------------------------
题目意思：
一条狭长的纸带被均匀划分出了n个格子,格子编号从1到n。每个格子上都染了一种颜色color_i(用[1,m]当中的一个整数表示),并且写了一个数字number_i。
定义一种特殊的三元组:(x,y,z),其中x,y,z都代表纸带上格子的编号,这里的三元组要求满足以下两个条件:
1.x,y,z都是整数,x<y<z,y−x=z−y。
2.color_x= color_z。
满足上述条件的**三元组的分数**规定为(x+z)∗(number_x+number_z)。**整个纸带的分数**规定为所有满足条件的三元组的分数的和。这个分数可能会很大,你只要输出
整个纸带的分数除以10,007所得的余数即可。
限制:对于第1组至第2组数据,1≤n≤100,1≤m≤5;对于第3组至第4组数据,1≤n≤3000,1≤m≤100;
对于第5组至第6组数据,1≤n≤100000,1≤m≤100000,且不存在出现次数超过20的颜色;
对于全部10组数据,1≤n≤100000,1≤m≤100000,1≤color_i≤m,1≤number_i≤100000。
-----------------------------------------------------------------------------------------------------------------------------------------
解题思路：
题目中说到:颜色的出现次数,因此很容易想到与颜色有关。
如果一个一个的去往后校对的话,10^10必然是超时的。
因此可以遍历一遍,把每一种颜色分出来,
相同的颜色的位置记录在一块。
这样,循环m次,每次把这一部分的颜色按要求算即可。
当然,这一种方法是可以过题目的。
但是,如果有相对比较极端的样例,比如:
100000 1
1 2 3 4 5 ………… 100000(都是不大于100000的数)
1 1 1 1 1 1 1 1 1 1 1 ………… 1(都是1)
就会过不去的。
-----------------------------------------------------------------------------------------------------------------------------------------
伪代码：
for (long long i=1;i<=n;i++) //按颜色分入数组;
for (long long i=1;i<=m;i++) //排序，方便下面的比较;
for (long long i=1;i<=m;i++)
	for (long long j=0;j<v[i].size();j++)
		for (long long k=j+1;k<v[i].size();k++)
			if (//符合要求) 按要求计算;
-----------------------------------------------------------------------------------------------------------------------------------------
错误原因:
一开始是用的贪心的算法,
通过一些改进,把y−x=z−y变成y+y=z+x然后再去遍历。
但复杂度仍会接近O(n^2)。
for (long long i=1;i<=n-2;i++)
	for (long long j=i+2;j<=n;j+=2)
		if (b[i]==b[j]){
  		long long b=a[i]+a[j],c=i+j;
			ans+=b*c;
			ans%=10007;
		}
